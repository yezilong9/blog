<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>http://blog.lo168.com/</title>
   
   <link>http://blog.lo168.com/</link>
   <description>遇到问题时冷静对待，这或许不能解决问题<br>但能使你收获更多</description>
   <language>zh-cn</language>
   <managingEditor> 叶子</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>让SpringMVC接收PUT方法</title>
	  <link>//%E8%AE%A9springMVC%E6%8E%A5%E6%94%B6PUT%E8%AF%B7%E6%B1%82</link>
	  <author>叶子</author>
	  <pubDate>2015-07-11T18:18:00+08:00</pubDate>
	  <guid>//%E8%AE%A9springMVC%E6%8E%A5%E6%94%B6PUT%E8%AF%B7%E6%B1%82</guid>
	  <description><![CDATA[
	     <h3>暂时只支持 application/x-www-form-urlencoded</h3>

<p>spring加入bean
<code>java
@Bean
public Filter initializeHttpPutHandler(){
    return new HttpPutFormContentFilter();
}
</code></p>

<p>即可使springmvc程序接收put的form表单请求。暂时只支持application/x-www-form-urlencoded
后续会开发form-data的方式</p>

	  ]]></description>
	</item>

	<item>
	  <title>使用netty构建简单的WebSocket</title>
	  <link>//%E4%BD%BF%E7%94%A8netty%E6%9E%84%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84WebSocket</link>
	  <author>叶子</author>
	  <pubDate>2015-07-07T18:18:00+08:00</pubDate>
	  <guid>//%E4%BD%BF%E7%94%A8netty%E6%9E%84%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84WebSocket</guid>
	  <description><![CDATA[
	     <p>websocket客户端可以有很多种，一种是网页实现socket.io,一种使用html5直接新建websocket。我这里使用了html5本身的websocket api。</p>

<p>因为只是demo，所以我这里不对其进行过多的代码分析和项目讲解，日后我会在这个demo进行项目构建，会是一个大型的聊天室？会是一个高性能的socket通讯系统？大家敬请期待吧！</p>

<p>demo地址：<a href="https://github.com/yezilong9/WebSocketDemo">WebSocketDemo</a></p>

	  ]]></description>
	</item>

	<item>
	  <title>设计模式之模板方法(java实现)</title>
	  <link>//%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95(java%E5%AE%9E%E7%8E%B0)</link>
	  <author>叶子</author>
	  <pubDate>2015-04-06T18:18:00+08:00</pubDate>
	  <guid>//%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95(java%E5%AE%9E%E7%8E%B0)</guid>
	  <description><![CDATA[
	     <p>首先大家可以先想想一个场景，就是炮制饮料。
我们第一步需要把水煮好，然后倒入相应的材料，倒入杯子中，然后加入该饮料一些添加剂。这里4个步骤换成别的饮料也是一样需要执行。所以我们写一个模板，让饮料们来继承实现</p>

<p>新建一个模板类：
```java
/<em>*
 * 模板超类
 </em>/
public abstract class RefreshBeverage {</p>

<pre><code>public final void prepareBeverageTemplate(){
    boilWater();//帮水煮沸
    brew();//炮制饮料
    pourInCup();//倒入杯子中
    addCondiments();//加入调味料
}

/**
 * 公共方法,private为了限制必须要遵从模板
 */
private void boilWater(){
    System.out.println("把水煮沸了！");
}

private void pourInCup(){
    System.out.println("倒入杯子中了！");
}



/**
 * 以下是各自子类不同的方法实现
 */
protected abstract void brew();

protected abstract void addCondiments();
</code></pre>

<p>}
```
然后可以看到里面煮水和倒入杯子两个方法，放在任何饮料也是需要执行的，所以我们子类不需要实现，要实现的是其中需要变化的方法。例如加入该饮料的材料和炮制过程</p>

<p>咖啡：
```java
public class Coffee extends RefreshBeverage {
    @Override
    protected void brew() {
        System.out.println("炮制咖啡");
    }</p>

<pre><code>@Override
protected void addCondiments() {
    System.out.println("加入糖让咖啡更加甜");
}
</code></pre>

<p>}
```</p>

<p>茶:
```java
public class Tea extends RefreshBeverage {
    @Override
    protected void brew() {
        System.out.println("倒入茶叶");
    }</p>

<pre><code>@Override
protected void addCondiments() {
    System.out.println("加入牛奶,变成奶茶");
}
</code></pre>

<p>}
<code>
测试：
</code>java
public class Test {</p>

<pre><code>public static void  main(String ...arg){
    RefreshBeverage r1 = new Coffee();
    r1.prepareBeverageTemplate();

    RefreshBeverage r2 = new Tea();
    r2.prepareBeverageTemplate();
}
</code></pre>

<p>}
```</p>

<p>ok，这里只是一个简单的实现，实际应用场景又会是怎么样的呢？
这里叶子本人遇到了一个需求，就是阅读数。
这个阅读数有分 文章阅读数和在微信的阅读数（在同一个表分别两个不同字段），以及分享之后的阅读数（不同表）
这里就涉及两个model，一个是article类，一个是shared类</p>

<p>模板:
```java
public abstract class ReadNumTemplate {</p>

<pre><code>private static final Logger logger = LoggerFactory.getLogger(ReadNumTemplate.class);
private static final long TIME = 3600000l;

private String redisKey;
private RedisService redisService;
private String redisTimeKey;
private Constant constant;
private GenericMongoDao genericMongoDao;
private boolean isBuild = false;

protected void build(String redisKey,
                     RedisService redisService,
                     Constant constant,
                     GenericMongoDao genericMongoDao){
    this.redisKey = redisKey;
    this.redisService = redisService;
    this.redisTimeKey = redisKey + "_time";
    this.constant = constant;
    this.genericMongoDao = genericMongoDao;
    this.isBuild = true;
}


/**
 * 阅读数统一模板方法
 * @return
 */
protected final Long addReadNum(){
    if(!isBuild){
        throw new RuntimeException("ReadNumTemplete is not build");
    }
    if (!redisService.exists(redisTimeKey)) {
        redisService.set(redisTimeKey, String.valueOf(System.currentTimeMillis()));
    }
    Long count = redisService.incr(redisKey);
    if(isSave(count)){
        saveToDb();
    }
    return syncho(count);
}


/**
 * 是否能保存
 * @param count
 * @return
 */
private boolean isSave(Long count){
    return count % constant.MAX_READ_COUNT == 0 || arriveTime();
}


/**
 * 判断时间是否已经达到存入数据库的临界值
 * @return
 */
private boolean arriveTime() {
    String timeValue = redisService.get(redisTimeKey);
    if (redisService.exists(redisTimeKey)) {
        long time = System.currentTimeMillis() - Long.parseLong(timeValue);
        if (time &gt; TIME) {
            redisService.set(redisTimeKey, String.valueOf(System.currentTimeMillis()));
            logger.info(MessageFormat.format(getName() + ":{0}达到1小时，可以保存数据库", redisKey));
            return true;
        } else {
            return false;
        }
    } else {
        return false;
    }
}

/**
 * 同步方法
 */
private Long syncho(Long redisCount) {
    Long dbCount = getDbCount();
    if (dbCount == null) {
        dbCount = 0l;
    }
    if (redisCount &lt; dbCount) {
        redisService.set(redisKey, String.valueOf(dbCount));
    }
    if (redisCount % constant.MAX_READ_COUNT == 0) {
        return  dbCount + constant.MAX_READ_COUNT;
    } else {
        return  dbCount &lt; redisCount ? redisCount : dbCount;
    }
}
private Long getRedisCount(){
    if(redisService.exists(redisKey)){
        return Long.parseLong(redisService.get(redisKey));
    }else{
        return 0L;
    }
}

/**
 * 异步保存到数据库
 */
@Async
private void saveToDb() {
    genericMongoDao.updateDefindProperty("id", getId(), getProperty(), getRedisCount());
}

protected abstract String getName();

protected abstract String getId();

protected abstract Long getDbCount();

protected abstract String getProperty();
</code></pre>

<p>}
```
代码还是比较烂，大家海涵。我先分析一下代码。这里有公共方法：
1. 保存阅读数到数据库。
2. 获取redis里面的阅读数。
3. 判断是否能保存。(判断条件是是否已经到达200条，或者这个key是否保存在redis超过1小时)
4. 保存该reidskey的时间（因为要用到判断是否已经达到1小时）</p>

<p>其中文章阅读数:
```java
public class ArticleReadNumService extends ReadNumTemplate {</p>

<pre><code>private Article article;

private ArticleReadNumService(){}

public static ArticleReadNumService create(Article article, RedisService redisService, Constant constant, ArticleRepository articleRepository){
    ArticleReadNumService articleReadNumService  = new ArticleReadNumService();
    articleReadNumService.article = article;
    articleReadNumService.build(constant.read_count_key + articleReadNumService.article.getId(),
            redisService, constant,articleRepository);
    return articleReadNumService;
}


@Override
protected String getName() {
    return "文章阅读数";
}

@Override
protected String getId() {
    return article.getId();
}

@Override
protected Long getDbCount() {
    return article.getRead_num();
}

@Override
protected String getProperty() {
    return "read_num";
}
</code></pre>

<p>}
```</p>

<p>微站阅读数:
```java
public class WzReadNumService extends ReadNumTemplate{</p>

<pre><code>private Article article;

public static WzReadNumService create(Article article, RedisService redisService, Constant constant,ArticleRepository articleRepository){
    WzReadNumService wzReadNumService = new WzReadNumService();
    wzReadNumService.article = article;
    String redisKey = constant.weixin_read_count_key + article.getId();
    wzReadNumService.build(redisKey, redisService, constant, articleRepository);
    return wzReadNumService;
}

@Override
protected String getName() {
    return "微站阅读数";
}

@Override
protected String getId() {
    return article.getId();
}

@Override
protected Long getDbCount() {
    return article.getWx_read_num();
}

@Override
protected String getProperty() {
    return "wx_read_num";
}
</code></pre>

<p>}
```</p>

<p>分享阅读数:
```java
public class SharedReadNumService extends ReadNumTemplate{</p>

<pre><code>private SharedRecord sharedRecord;

public static SharedReadNumService create(SharedRecord sharedRecord, RedisService redisService, Constant constant, SharedRecordRepository sharedRecordRepository){
    SharedReadNumService sharedReadNumService = new SharedReadNumService();
    sharedReadNumService.sharedRecord = sharedRecord;
    sharedReadNumService.build(constant.shared_read_count_key+sharedRecord.getId(),redisService,constant,sharedRecordRepository);
    return sharedReadNumService;
}

@Override
protected String getName() {
    return "分享阅读数";
}

@Override
protected String getId() {
    return sharedRecord.getId();
}


@Override
protected Long getDbCount() {
    return sharedRecord.getReadNum().longValue();
}

@Override
protected String getProperty() {
    return "shared_record";
}
</code></pre>

<p>}
```</p>

<pre><code>可以看出来，里面各个子类需要做的东西已经是很少了，这样大大增加了可读性和维护。而公共方法的private就是为了限制这个模板只能是给差不多的类使用。
唯一不满意就是里面一个build方法，因为需要把bean传进去给模板方法，不得而为之，如果各位小伙伴有更好的提议不妨给我留言。

模板方法大致介绍完毕，如果各位小伙伴有更好的实际需求应用模板方法的，可以留言提出让叶子也多学习学习。
</code></pre>

	  ]]></description>
	</item>

	<item>
	  <title>springboot用maven打独立应用的jar包</title>
	  <link>//springboot%E5%88%A9%E7%94%A8maven%E6%89%93%E7%8B%AC%E7%AB%8B%E5%BA%94%E7%94%A8jar%E5%8C%85</link>
	  <author>叶子</author>
	  <pubDate>2015-03-03T18:18:00+08:00</pubDate>
	  <guid>//springboot%E5%88%A9%E7%94%A8maven%E6%89%93%E7%8B%AC%E7%AB%8B%E5%BA%94%E7%94%A8jar%E5%8C%85</guid>
	  <description><![CDATA[
	     <p>如果用过spring boot的都知道，其引入了嵌入式web容器运行的。但是如果打包成jar包，方便是方便，但是无法通过修改配置文件--重启应用就达到想要的效果，必须又要重新打一个jar包。而lib依赖也是如此，很多时候都可以不变的，没必要发布都要打包吧。
以下内容你将会学到如何利用maven插件构建独立jar包，发布应用到正式环境的流程。</p>

<pre><code>这里会使用到maven，如果不熟识的自行先去补习以下：）
假设你已经有了spring boot应用，你就可以执行以下操作
</code></pre>

<h3>第一步：修改pom配置</h3>

<p>我继续使用动态构建目标环境的配置，如果不熟识，可以先去<a href="http://blog.lo168.com/maven%E6%9E%84%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E8%AF%BB%E5%8F%96%E4%B8%8D%E5%90%8C%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.html">maven构建不同环境读取不同的配置文件</a>看看复习一下</p>

<p>配置部分:
```xml
<profiles>
        <!-- 开发环境，默认激活 -->
        <profile>
            <id>dev</id>
            <properties>
                <env>dev</env>
            </properties>
            <activation>
                <activeByDefault>true</activeByDefault>
            </activation>
        </profile></p>

<pre><code>    &lt;!-- 正服 --&gt;
    &lt;profile&gt;
        &lt;id&gt;product&lt;/id&gt;
        &lt;properties&gt;
            &lt;env&gt;product&lt;/env&gt;
        &lt;/properties&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;
</code></pre>

<p><build>
<resources>
            <resource>
                <directory>${project.basedir}/src/main/resources/${env}</directory>
                <includes>
                    <include>application.properties</include>
                </includes>
                <filtering>true</filtering>
            </resource>
        </resources>
        <sourceDirectory>src/main/java</sourceDirectory>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <configuration>
                    <archive>
                        <manifest>
                            <addClasspath>true</addClasspath>
                            <!-- 加载的class目录的前缀（依赖的jar目录） -->
                            <classpathPrefix>lib/</classpathPrefix>
                            <!-- 入口 -->
                            <mainClass>com.test.jpa.ApiService</mainClass>
                        </manifest>
                    </archive>
                </configuration>
            </plugin>
            <!-- 把依赖的jar包拷到lib目录下 -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-dependency-plugin</artifactId>
                <executions>
                    <execution>
                        <id>copy-dependencies</id>
                        <phase>package</phase>
                        <goals>
                            <goal>copy-dependencies</goal>
                        </goals>
                        <configuration>
                            <outputDirectory>${project.build.directory}/lib</outputDirectory>
                            <overWriteReleases>false</overWriteReleases>
                            <overWriteSnapshots>false</overWriteSnapshots>
                            <overWriteIfNewer>true</overWriteIfNewer>
                        </configuration>
                    </execution>
                </executions>
            </plugin></p>

<pre><code>        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.3&lt;/version&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;id&gt;copy-resources&lt;/id&gt;
                    &lt;phase&gt;package&lt;/phase&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;copy-resources&lt;/goal&gt;
                    &lt;/goals&gt;
                    &lt;configuration&gt;
                        &lt;encoding&gt;UTF-8&lt;/encoding&gt;
                        &lt;!-- 把配置文件拷到和jar包同一个路径下 --&gt;
                        &lt;outputDirectory&gt;${project.build.directory}&lt;/outputDirectory&gt;
                        &lt;resources&gt;
                            &lt;resource&gt;
                                &lt;directory&gt;src/main/resources/${env}/&lt;/directory&gt;
                                &lt;includes&gt;
                                    &lt;include&gt;application.properties&lt;/include&gt;
                                &lt;/includes&gt;
                                &lt;filtering&gt;true&lt;/filtering&gt;
                            &lt;/resource&gt;
                        &lt;/resources&gt;
                    &lt;/configuration&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
        &lt;!-- 打jar包时需要把配置文件给排除在外 --&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;phase&gt;package&lt;/phase&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;jar&lt;/goal&gt;
                    &lt;/goals&gt;
                    &lt;configuration&gt;
                        &lt;classifier&gt;${env}&lt;/classifier&gt;
                        &lt;excludes&gt;
                            &lt;exclude&gt;application.properties&lt;/exclude&gt;
                        &lt;/excludes&gt;
                    &lt;/configuration&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>

<pre><code>我没有copy模块名称和依赖的配置，因为各有各不同。
其中大家可以留意
</code></pre>

<p><id>copy-resources</id>
<phase>package</phase>
<goals>
    <goal>copy-resources</goal>
</goals>
<configuration>
    <encoding>UTF-8</encoding>
    <!-- 把配置文件拷到和jar包同一个路径下 -->
    <outputDirectory>${project.build.directory}</outputDirectory>
    <resources>
        <resource>
            <directory>src/main/resources/${env}/</directory>
            <includes>
                <include>application.properties</include>
            </includes>
            <filtering>true</filtering>
        </resource>
    </resources>
</configuration>
```
这个是重点，把配置文件copy到jar包同级目录，并且指定outputDirectory是读取同级目录的配置文件为springboot的自身配置。lib依赖包同理，我就不多说了。</p>

<h3>第二步：执行maven命令</h3>

<p>读过我那篇maven不同环境配置都知道，maven打包命令应该是:
<code>Bash
mvn clean package -P${env}
</code>
假设我要发布一个正式环境的jar包，那应该就是:
<code>Bash
mvn clean package -Pproduct
</code></p>

<p>ok，执行完命令之后，去程序目录的target里面看看是否已经生产了配置文件，jar包，还有lib依赖文件夹？
因为方便区别，我特意把包的别名改成环境的别名，留意这一段：
```xml
<configuration>
  <classifier>${env}</classifier>
    <excludes>
        <exclude>application.properties</exclude>
    </excludes>
</configuration></p>

<pre><code>这样打出来的包名为:**xxx-1.0-SNAPSHOT-product.jar**

### 第三步：执行命令并修改配置重启
各位应该都跃跃欲试了，到这一步就可以执行命令来看看是否成功。
</code></pre>

<p>java -jar xxx-1.0-SNAPSHOT-product.jar
```</p>

<p>如果启动没问题，就说明lib依赖和配置文件能够正确读取，jar应用正确分离出来了。
这样，小伙伴们就能随便修改配置文件而不需要重新打包啦:-)</p>

<pre><code>那如果更新到外网，那我们就可以区分多种更新了。
1.更新应用代码，也就是jar包，重启。
2.只更新配置文件，重启。

这样问题就来了？如何才能更加方便自己去发布不同地址服务器，并执行停止，启动或重启动作呢？
这样的话，就要用到shell脚本了。编写这样的脚本，发布动作就变得异常简单。欲知如何编写？叶子下回分解
</code></pre>

	  ]]></description>
	</item>

	<item>
	  <title>spring mvc mongo集群(xml和注解)</title>
	  <link>//spring-mvc-mongo%E9%9B%86%E7%BE%A4(xml%E5%92%8C%E6%B3%A8%E8%A7%A3)</link>
	  <author>叶子</author>
	  <pubDate>2015-02-02T18:18:00+08:00</pubDate>
	  <guid>//spring-mvc-mongo%E9%9B%86%E7%BE%A4(xml%E5%92%8C%E6%B3%A8%E8%A7%A3)</guid>
	  <description><![CDATA[
	     <p>最新实在太忙，公司每晚加班，都没时间更新博客让大家吸收营养了。所以赶紧出点干货给大家:)</p>

<p>以下内容你将会学到如何使用spring xml和注解方式集群配置mongodb，以及简单的mongoTemplate源码学习
注意：前提是mongodb本身配置好主从模式！</p>

<p>在数据越来越最求读取性能的时候，mongodb必须是大家非常喜爱的nosql数据库。spring对mongodb数据库的支持也是非常友好，既有jpa方式的操作，也有template方式操作。这里重点讲template，其spring工具类是mongoTemplate，里面包括所有的mongo操作。当然了，大家还是需要基于这个工具类去封装一层更加便于自己操作的类，下面会介绍到。。。</p>

<p>叶子是以spring boot来讲解的。例如springmvc，ssh等xml配置都是差不多的</p>

<h3>首先我们来添加pom文件依赖</h3>

<pre><code class="xml">&lt;dependency&gt;
    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;/dependency&gt;
</code></pre>

<p>这个依赖大家可以进去看看，里面已经包括了driver和data的包，不是spring-boot的话是要添加以下这两个包了</p>

<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.mongodb&lt;/groupId&gt;
    &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt;
    &lt;version&gt;2.12.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
    &lt;artifactId&gt;spring-data-mongodb&lt;/artifactId&gt;
    &lt;version&gt;1.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<h3>xml配置mongodb</h3>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mongo="http://www.springframework.org/schema/data/mongo" xsi:schemaLocation="http://www.springframework.org/schema/context
          http://www.springframework.org/schema/context/spring-context-3.0.xsd
          http://www.springframework.org/schema/data/mongo
          http://www.springframework.org/schema/data/mongo/spring-mongo-1.0.xsd
          http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;

    &lt;mongo:mongo replica-set="192.168.30.181:27017,192.168.30.183:27017"&gt;
        &lt;mongo:options connections-per-host="8"  auto-connect-retry="true" socket-keep-alive="true"  slave-ok="true"  /&gt;
    &lt;/mongo:mongo&gt;

    &lt;mongo:db-factory dbname="product" mongo-ref="mongo" /&gt;

    &lt;bean id="mappingContext" class="org.springframework.data.mongodb.core.mapping.MongoMappingContext" /&gt;

    &lt;bean id="defaultMongoTypeMapper" class="org.springframework.data.mongodb.core.convert.DefaultMongoTypeMapper"&gt;
        &lt;constructor-arg name="typeKey"&gt;&lt;null /&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;

    &lt;bean id="mappingMongoConverter" class="org.springframework.data.mongodb.core.convert.MappingMongoConverter"&gt;
        &lt;constructor-arg name="mongoDbFactory" ref="mongoDbFactory" /&gt;
        &lt;constructor-arg name="mappingContext" ref="mappingContext" /&gt;
        &lt;property name="typeMapper" ref="defaultMongoTypeMapper" /&gt;
    &lt;/bean&gt;

    &lt;bean id="mongoTemplate" class="org.springframework.data.mongodb.core.MongoTemplate"&gt;
        &lt;constructor-arg name="mongoDbFactory" ref="mongoDbFactory" /&gt;
        &lt;constructor-arg name="mongoConverter" ref="mappingMongoConverter" /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>

<h3>然后代码里面就可以引用这个配置文件了</h3>

<pre><code class="java">@Configuration
@EnableAutoConfiguration
@EnableAspectJAutoProxy(proxyTargetClass = true)
@ComponentScan("com.xiangrikui.content")
@ImportResource("classpath:mongo.xml")
public class ApiService extends WebMvcConfigurerAdapter {
    @Autowired
    HttpInterceptor httpInterceptor;

    public static void main(String[] args) {

        SpringApplication.run(ApiService.class, args);
    }
}
</code></pre>

<p>说完xml配置，那我们来谈谈注解配置。作为spring的脑残粉，xml当然是我们最痛恨的配置了，又长又啰嗦，注解才是我们需要的配置。spring boot本身就是“约定大于配置”而开发出来的框架，那spring boot如何注解配置呢，现在道来！</p>

<p>作为程序员，学一样东西当然先去下载，然后看官方文档啦，官方给出的配置是这样滴：</p>

<pre><code class="Bash"># MONGODB (MongoProperties)
spring.data.mongodb.host= # the db host
spring.data.mongodb.port=27017 # the connection port (defaults to 27107)
spring.data.mongodb.uri=mongodb://localhost/test # connection URL
spring.data.mongodb.database=
spring.data.mongodb.authentication-database=
spring.data.mongodb.grid-fs-database=
spring.data.mongodb.username=
spring.data.mongodb.password=
spring.data.mongodb.repositories.enabled=true # if spring data repository support is enabled
</code></pre>

<p>这样是默认的配置，在此，叶子先不使用默认配置，教教大家如何配置自定义mongodb的bean。 spring会默认读取官方配置文件里面的配置，然后构建mongoTemplate。看里面源码可以知道，生成mongoTemplate需要一个MongoDbFactory</p>

<pre><code class="java">/**
 * Constructor used for a basic template configuration.
 *
 * @param mongoDbFactory must not be {@literal null}.
 */
public MongoTemplate(MongoDbFactory mongoDbFactory) {
    this(mongoDbFactory, null);
}
</code></pre>

<p>而生成mongoDbFactory的实现SimpleMongoDbFactory又需要mongo这个类</p>

<pre><code class="java">/**
 * Create an instance of {@link SimpleMongoDbFactory} given the {@link Mongo} instance and database name.
 *
 * @param mongo Mongo instance, must not be {@literal null}.
 * @param databaseName database name, not be {@literal null} or empty.
 */
public SimpleMongoDbFactory(Mongo mongo, String databaseName) {
    this(mongo, databaseName, null);
}
</code></pre>

<p>但是细心的开发者可以看出mongo这个类已经放弃使用，里面方法也都是过期了，怎么办啊？ 别急，叶子找到了MongoClient这个类，继承了mongo类，持有MongoClientOptions的操作配置！这不就是我们要找的吗？</p>

<pre><code class="java">/*
 * Copyright (c) 2008-2014 MongoDB, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.mongodb;

import java.net.UnknownHostException;
import java.util.List;

public class MongoClient extends Mongo {

    private final MongoClientOptions options;

    public MongoClient() throws UnknownHostException {
        this(new ServerAddress());
    }


    public MongoClient(String host, int port) throws UnknownHostException {
        this(new ServerAddress(host, port));
    }

    public MongoClient(ServerAddress addr) {
        this(addr, new MongoClientOptions.Builder().build());
    }


    public MongoClient(ServerAddress addr, MongoClientOptions options) {
        this(addr, null, options);
    }


    public MongoClient(List&lt;ServerAddress&gt; seeds, List&lt;MongoCredential&gt; credentialsList) {
        this(seeds, credentialsList, new MongoClientOptions.Builder().build());
    }

    public MongoClient(MongoClientURI uri) throws UnknownHostException {
        super(new MongoURI(uri));
        this.options = uri.getOptions();
    }

    public List&lt;MongoCredential&gt; getCredentialsList() {
        return getAuthority().getCredentialsStore().asList();
    }

    public MongoClientOptions getMongoClientOptions() {
        return options;
    }
}
</code></pre>

<p>我删除这个类大部分不需要的方法，只留一些，方便各位小伙伴阅读。其中可以看出，集群不集群其实就是一个你是不是用集合地址的问题，ServerAddress如果是集合list的话，那就是集群了！是不是很简单 还有一种就是MongoClientURI，看里面源码就知道里面其实就是一个简单的截取字符串,我这里不全部讲解了，里面有个函数大家可以看看：Collections.addAll(all, serverPart.split(",")); 简单来说就是多个uri用逗号分隔。说到这里大家会惊叹，我TMD这样就集群了？太简单了吧！ 对于mongodb本身已经配置好集群，开发者再用代码去配置，确实很简单就能集群了 看图说话：</p>

<p><img src="http://7te9zv.com1.z0.glb.clouddn.com/mongorep2.png" alt="image" /></p>

<h3>言归正传！ 叶子的配置：</h3>

<pre><code class="Bash">#mongodb的uri，集群的话用逗号分隔
mongodb.uri=mongodb://192.168.30.181:27017,192.168.30.183:27017
mongodb.database=reader_production
</code></pre>

<p>然后新建一个mongodb配置类
```java
@Configuration
public class MongoConfiguration {</p>

<pre><code>@Value("${mongodb.uri}")
private String mongoURI;
@Value("${mongodb.database}")
private String dataBase;

@Bean
public MongoTemplate mongoTemplate() throws UnknownHostException {
</code></pre>

<p>//        List<ServerAddress> serverAddresses = Lists.newArrayList();
//        serverAddresses.add(new ServerAddress("192.168.30.181",27017));
//        serverAddresses.add(new ServerAddress("192.168.30.183",27017));
//        MongoClient client = new MongoClient(serverAddresses);
        MongoClient client = new MongoClient(new MongoClientURI(mongoURI));
        //优先从secondary节点进行读取操作，secondary节点不可用时从主节点读取数据
        client.setReadPreference(ReadPreference.secondaryPreferred());
        MongoDbFactory mongoDbFactory = new SimpleMongoDbFactory(client,dataBase);
        MongoTemplate mongoTemplate = new MongoTemplate(mongoDbFactory);
        MappingMongoConverter mongoConverter = (MappingMongoConverter) mongoTemplate.getConverter();
        //把spring data mongodb _class这个字段去掉
        mongoConverter.setTypeMapper(new DefaultMongoTypeMapper(null));
        return mongoTemplate;
    }
}
client.setReadPreference(ReadPreference.secondaryPreferred());</p>

<p>```
这里声明了主从模式是怎么样的，但是有个疑问就是，为啥mongoclient已经持有操作类，但是在mongoTemplate也持有呢？代码如此啰嗦是为什么？知道的可以告诉一下叶子哈:)</p>

<h3>主从模式基本参数是：</h3>

<pre><code>primary:默认参数，只从主节点上进行读取操作；
primaryPreferred:大部分从主节点上读取数据,只有主节点不可用时从secondary节点读取数据。
secondary:只从secondary节点上进行读取操作，存在的问题是secondary节点的数据会比primary节点数据“旧”。
secondaryPreferred:优先从secondary节点进行读取操作，secondary节点不可用时从主节点读取数据；
nearest:不管是主节点、secondary节点，从网络延迟最低的节点上读取数据。
</code></pre>

<p>这样就完成配置，xml和注解都一样是需要引入mongoTemplate才能去做操作的，如何操作这里就不作介绍了，以免文章杂而无章。</p>

	  ]]></description>
	</item>

	<item>
	  <title>twemproxy 部署文档</title>
	  <link>//twemproxy-%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3</link>
	  <author>叶子</author>
	  <pubDate>2015-01-04T18:18:00+08:00</pubDate>
	  <guid>//twemproxy-%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3</guid>
	  <description><![CDATA[
	     <h3>简介</h3>

<p>twemproxy 主要用于Redis 和 Memcached 的集群代理</p>

<h3>功能介绍</h3>

<p>我们知道，无论是 Memcached 还是当前的 Redis，其本身都不具备分布式集群特性，当我们有大量 Redis 或 Memcached 的时候，通常只能通过客户端的一些数据分配算法（比如一致性哈希），来实现集群存储的特性。 而 Twemproxy 通过引入一个代理层，可以将其后端的多台 Redis 或 Memcached 实例进行统一管理与分配，使应用程序只需要在 Twemproxy 上进行操作，而不用关心后面具体有多少个真实的 Redis 或 Memcached 存储。 在 Redis 的 Cluster 方案还没有正式推出之前，通过 Proxy 的方式来实现存储集群可能是最好的选择了。更何况 Twemproxy 是通过 Twitter 自身得到了充分检验的产品。</p>

<h3>性能</h3>

<p>根据 Redis 作者的测试结果，在大多数情况下，Twemproxy 的性能相当不错，直接操作 Redis 相比，最多只有20%的性能损失。这对于它带来的好处来说真的是微不足道了。唯一可能还有待改进的是其 MGET 操作的效率，其性能只有直接操作 Redis 的 50%。</p>

<h3>安装与配置</h3>

<p>线上部署与安装, twenproxy 部署到170上,安装目录/opt/module/twenproxy</p>

<pre><code class="Bash">apt-get install automake
apt-get install libtool
git clone git://github.com/twitter/twemproxy.git
cd twemproxy
autoreconf -fvi
./configure --enable-debug=log
make
src/nutcracker -h
</code></pre>

<p>输入src/nutcracker -h 在命令行可以显示帮助信息,那么就证明安装成功</p>

<pre><code>1.假如192.168.30.170的redis跟192.168.30.171的redis安装成功
2.现在通过twenproxy代理集群
3.直接看/opt/module/twenproxy/conf/nutcracker.xrk.yml配置文件,还有很多配置参数详细请看 https://github.com/twitter/twemproxy

redis:
listen: 192.168.30.170:55555 #twenproxy部署在192.168.30.170:55555 上
hash: fnv1a_64
distribution: ketama
auto_eject_hosts: true
preconnect: true
server_connections: 50
redis: true
server_retry_timeout: 2000
server_failure_limit: 1
servers:
- 192.168.30.170:6379:1 #部署170的redis
- 192.168.30.171:6380:1 #部署171的redis
</code></pre>

<h3>启动服务</h3>

<pre><code class="Bash">cd /opt/module/twenproxy
#查看命令信息
./src/nutcracker -h
Usage: nutcracker [-?hVdDt] [-v verbosity level] [-o output file]
              [-c conf file] [-s stats port] [-a stats addr]
              [-i stats interval] [-p pid file] [-m mbuf size]
Options:
  -h, --help             : this help #帮助
  -V, --version          : show version and exit #版本
  -t, --test-conf        : test configuration for syntax errors and exit #测试配置文件是否有语法错误
  -d, --daemonize        : run as a daemon #是否守护进程启动
  -D, --describe-stats   : print stats description and exit #描述
  -v, --verbosity=N      : set logging level (default: 5, min: 0, max: 11)
  -o, --output=S         : set logging file (default: stderr)
  -c, --conf-file=S      : set configuration file (default: conf/nutcracker.yml) #指定配置文件
  -s, --stats-port=N     : set stats monitoring port (default: 22222) #端口
  -a, --stats-addr=S     : set stats monitoring ip (default: 0.0.0.0) #设置地址
  -i, --stats-interval=N : set stats aggregation interval in msec (default: 30000 msec)
  -p, --pid-file=S       : set pid file (default: off)
  -m, --mbuf-size=N      : set size of mbuf chunk in bytes (default: 16384 bytes)
#查看命令信息
#启动命令
1. 为了方便调试启动
./src/nutcracker -c /opt/module/twenproxy/conf/nutcracker.xrk.yml
2.守护进程启动
./src/nutcracker -d -c /opt/module/twenproxy/conf/nutcracker.xrk.yml
</code></pre>

<h3>连接并测试是否成功</h3>

<pre><code class="Bash">redis-cli -h 192.168.30.170 -p 55555
连接失败:
提示信息:Could not connect to Redis at 192.168.9.13:55555: Connection refused
连接成功:
提示信息:redis 192.168.30.170:55555&gt;
set key1 1
get key1
</code></pre>

<p>以上是twenproxy安装配置与测试连接</p>

<h3>优点</h3>

<p>这是一个轻量级的 Redis和memcached代理。使用它可以减少缓存服务器的连接数，并且利用它来作分片。这个代理的速度是相当快的，明月在网上查到会有20%的性 能损耗，但明月用redis-benchmark做了测试，发现性能几乎是无损的，甚至有时更快。后来找到英文原文，作者是说最差情况下，性能损耗不会多 于20%。明月觉得这个很了不起，按道理说，有了一层代理，怎么说都得折损一部分性能，但是他切能使得访问更快。看了源码，原来是用了pipeline. 首先redis是支持使用pipeline批处理的。twemproxy与每个redis服务器都会建立一个连接，每个连接实现了两个FIFO的队列，通 过这两个队列实现对redis的pipeline访问。将多个客户端的访问合并到一个连接,这样既减少了redis服务器的连接数，又提高了访问性能。</p>

<h3>缺点</h3>

<ol>
<li>虽然可以动态移除节点，但该移除节点的数据就丢失了。</li>
<li>redis集群动态增加节点的时候,twemproxy不会对已有数据做重分布.maillist里面作者说这个需要自</li>
<li>性能上的损耗</li>
</ol>


	  ]]></description>
	</item>

	<item>
	  <title>maven构建不同环境读取不同的配置文件</title>
	  <link>//maven%E6%9E%84%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E8%AF%BB%E5%8F%96%E4%B8%8D%E5%90%8C%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6</link>
	  <author>叶子</author>
	  <pubDate>2015-01-01T18:18:00+08:00</pubDate>
	  <guid>//maven%E6%9E%84%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E8%AF%BB%E5%8F%96%E4%B8%8D%E5%90%8C%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6</guid>
	  <description><![CDATA[
	     <p>众所周知maven是java开发的利器，他的强大之处不同我多说了。这次为大家带来的就是maven对应不同环境的部署，以及未来给各位介绍jenkins构建项目做铺垫。</p>

<p>首先，我已一个spring-boot项目为例子讲解，举一反三，其他项目也是同样原理的，或者有部分配置不同而已。</p>

<h3>pom.xml代码:</h3>

<p>在project根下加入</p>

<pre><code class="xml">&lt;profiles&gt;

 &lt;!-- 开发环境，默认激活 --&gt;
     &lt;profile&gt;
        &lt;id&gt;dev&lt;/id&gt;
      &lt;properties&gt;
         &lt;env&gt;dev&lt;/env&gt;
       &lt;/properties&gt;
       &lt;activation&gt;
            &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
       &lt;/activation&gt;
 &lt;/profile&gt;

 &lt;!-- 测服 --&gt;
 &lt;profile&gt;
      &lt;id&gt;test&lt;/id&gt;
        &lt;properties&gt;
           &lt;env&gt;test&lt;/env&gt;
        &lt;/properties&gt;
 &lt;/profile&gt;

 &lt;!-- 正服 --&gt;
  &lt;profile&gt;
      &lt;id&gt;product&lt;/id&gt;
       &lt;properties&gt;
         &lt;env&gt;product&lt;/env&gt;
       &lt;/properties&gt;
  &lt;/profile&gt;

 &lt;/profiles&gt;
</code></pre>

<h3>然后找到build根节点，在里面加入资源路径引入</h3>

<p>```xml</p>

<!--资源引入-->


<p><resources>
     <resource>
           <directory>${project.basedir}/src/main/resources/${env}</directory>
        <includes>
             <include>application.properties</include>
        </includes>
      <filtering>true</filtering><!--这个相当重要，不加就不能动态构建不同资源了-->
     </resource>
 </resources></p>

<!--构建的主要插件-->


<p> <plugins>
      <plugin>
         <groupId>org.springframework.boot</groupId>
         <artifactId>spring-boot-maven-plugin</artifactId>
      </plugin></p>

<p> <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-war-plugin</artifactId>
      <configuration>
         <warName>tiles</warName>
       <archive>
         <addMavenDescriptor>false</addMavenDescriptor>
       </archive>
   <webResources>
       <resource>
           <directory>src/main/resources/${env}/application.properties</directory>
           <filtering>true</filtering>
       </resource>
   </webResources>
       </configuration>
 </plugin></p>

<p> </plugins>
```
大家请看插件中有war包的插件，这个就是最终构建成可发布版本时用到的。</p>

<p>当中webResources就是读取项目中的配置文件操作，请细看里面部分，directory就是读取的配置文件路径${env}大家应该都知道了，就是我们上面配置的项目环境的变量，当打包为test的时候，env = test。所以这样就能直接构建时动态读取需要的配置文件了。</p>

<h3>最后的知识点（重要）：</h3>

<pre><code class="Bash">这样我们就能打包时传入构建项目的目标环境了。。。
命令如下：mvn clean package -P目标环境代码
如我要配置到测试环境的，那就是mvn clean package -Ptest
so：之后我会和大家探讨jenkins，那jenkins就可以约定好测试环境为test，生产是product来构建项目了。（后话）

其他配置我就不写上去了，其他只不过就是项目的名称版本和所拥有的依赖。
</code></pre>

	  ]]></description>
	</item>


</channel>
</rss>
